
user  nginx;
worker_processes  1;

pid        /var/run/nginx.pid;
error_log  /var/log/nginx/nginx.error.log warn;

events {
    worker_connections  1024;
}


http {

    limit_req_zone $binary_remote_addr zone=pay_center:10m rate=1r/s;

    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /dev/null;
    #access_log  /var/log/dnmp/nginx.access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。
    #这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。
    #没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）
    keepalive_timeout  6500;

    ##与代理服务器的建立连接超时时间，不能超过75s ？
    proxy_connect_timeout 10;
    #与代理服务器的读超时时间
    proxy_read_timeout 6500;
    ##与代理服务器的发送请求超时时间
    proxy_send_timeout 10;

    #设置xdebug特殊超时时间

    #指定nginx与后端fastcgi server创建连接超时时间，建立连接失败，如连接到错误端口 http error 502， 或者php-fpm主动断开连接也是502
    fastcgi_connect_timeout 10;
    #指定nginx接受后端fastcgi响应请求超时时间 （指已完成两次握手后nginx接受读取fastcgi响应请求超时时间）
    #设置最大的等待fastcgi响应时间为3600s, 60m http error 504, 即nginx超过了自己设置的超时时间，不等待php-fpm的返回结果，直接给客户端返回504错误。
    #但是此时php-fpm依然还在处理请求（在没有超出自己的超时时间的情况下）。
    fastcgi_read_timeout 3600;
    #指定nginx向后端传送请求超时时间（指已完成两次握手后向fastcgi传送请求超时时间）, http error 503 ？
    fastcgi_send_timeout 10;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
